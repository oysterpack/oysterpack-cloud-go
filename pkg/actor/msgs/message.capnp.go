// Code generated by capnpc-go. DO NOT EDIT.

package msgs

import (
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Envelope struct{ capnp.Struct }

// Envelope_TypeID is the unique identifier for the type Envelope.
const Envelope_TypeID = 0xf38cccd618967ecd

func NewEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4})
	return Envelope{st}, err
}

func NewRootEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4})
	return Envelope{st}, err
}

func ReadRootEnvelope(msg *capnp.Message) (Envelope, error) {
	root, err := msg.RootPtr()
	return Envelope{root.Struct()}, err
}

func (s Envelope) String() string {
	str, _ := text.Marshal(0xf38cccd618967ecd, s.Struct)
	return str
}

func (s Envelope) Id() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Envelope) HasId() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Envelope) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Envelope) SetId(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Envelope) Created() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Envelope) SetCreated(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Envelope) ReplyTo() (ChannelAddress, error) {
	p, err := s.Struct.Ptr(1)
	return ChannelAddress{Struct: p.Struct()}, err
}

func (s Envelope) HasReplyTo() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Envelope) SetReplyTo(v ChannelAddress) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewReplyTo sets the replyTo field to a newly
// allocated ChannelAddress struct, preferring placement in s's segment.
func (s Envelope) NewReplyTo() (ChannelAddress, error) {
	ss, err := NewChannelAddress(s.Struct.Segment())
	if err != nil {
		return ChannelAddress{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope) Channel() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s Envelope) HasChannel() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Envelope) ChannelBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s Envelope) SetChannel(v string) error {
	return s.Struct.SetText(2, v)
}

func (s Envelope) Message() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Envelope) HasMessage() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Envelope) SetMessage(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Envelope) MessageType() uint8 {
	return s.Struct.Uint8(8)
}

func (s Envelope) SetMessageType(v uint8) {
	s.Struct.SetUint8(8, v)
}

// Envelope_List is a list of Envelope.
type Envelope_List struct{ capnp.List }

// NewEnvelope creates a new list of Envelope.
func NewEnvelope_List(s *capnp.Segment, sz int32) (Envelope_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4}, sz)
	return Envelope_List{l}, err
}

func (s Envelope_List) At(i int) Envelope { return Envelope{s.List.Struct(i)} }

func (s Envelope_List) Set(i int, v Envelope) error { return s.List.SetStruct(i, v.Struct) }

func (s Envelope_List) String() string {
	str, _ := text.MarshalList(0xf38cccd618967ecd, s.List)
	return str
}

// Envelope_Promise is a wrapper for a Envelope promised by a client call.
type Envelope_Promise struct{ *capnp.Pipeline }

func (p Envelope_Promise) Struct() (Envelope, error) {
	s, err := p.Pipeline.Struct()
	return Envelope{s}, err
}

func (p Envelope_Promise) ReplyTo() ChannelAddress_Promise {
	return ChannelAddress_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Address struct{ capnp.Struct }

// Address_TypeID is the unique identifier for the type Address.
const Address_TypeID = 0x9fd358f04cb684bd

func NewAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func NewRootAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func ReadRootAddress(msg *capnp.Message) (Address, error) {
	root, err := msg.RootPtr()
	return Address{root.Struct()}, err
}

func (s Address) String() string {
	str, _ := text.Marshal(0x9fd358f04cb684bd, s.Struct)
	return str
}

func (s Address) Path() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Address) HasPath() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Address) SetPath(v capnp.TextList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Address) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Address) Id() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s Address) HasId() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Address) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s Address) SetId(v string) error {
	return s.Struct.SetText(1, v)
}

// Address_List is a list of Address.
type Address_List struct{ capnp.List }

// NewAddress creates a new list of Address.
func NewAddress_List(s *capnp.Segment, sz int32) (Address_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Address_List{l}, err
}

func (s Address_List) At(i int) Address { return Address{s.List.Struct(i)} }

func (s Address_List) Set(i int, v Address) error { return s.List.SetStruct(i, v.Struct) }

func (s Address_List) String() string {
	str, _ := text.MarshalList(0x9fd358f04cb684bd, s.List)
	return str
}

// Address_Promise is a wrapper for a Address promised by a client call.
type Address_Promise struct{ *capnp.Pipeline }

func (p Address_Promise) Struct() (Address, error) {
	s, err := p.Pipeline.Struct()
	return Address{s}, err
}

type ChannelAddress struct{ capnp.Struct }

// ChannelAddress_TypeID is the unique identifier for the type ChannelAddress.
const ChannelAddress_TypeID = 0xd801266d9df371b7

func NewChannelAddress(s *capnp.Segment) (ChannelAddress, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ChannelAddress{st}, err
}

func NewRootChannelAddress(s *capnp.Segment) (ChannelAddress, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ChannelAddress{st}, err
}

func ReadRootChannelAddress(msg *capnp.Message) (ChannelAddress, error) {
	root, err := msg.RootPtr()
	return ChannelAddress{root.Struct()}, err
}

func (s ChannelAddress) String() string {
	str, _ := text.Marshal(0xd801266d9df371b7, s.Struct)
	return str
}

func (s ChannelAddress) Channel() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s ChannelAddress) HasChannel() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChannelAddress) ChannelBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s ChannelAddress) SetChannel(v string) error {
	return s.Struct.SetText(0, v)
}

func (s ChannelAddress) Address() (Address, error) {
	p, err := s.Struct.Ptr(1)
	return Address{Struct: p.Struct()}, err
}

func (s ChannelAddress) HasAddress() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChannelAddress) SetAddress(v Address) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s ChannelAddress) NewAddress() (Address, error) {
	ss, err := NewAddress(s.Struct.Segment())
	if err != nil {
		return Address{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// ChannelAddress_List is a list of ChannelAddress.
type ChannelAddress_List struct{ capnp.List }

// NewChannelAddress creates a new list of ChannelAddress.
func NewChannelAddress_List(s *capnp.Segment, sz int32) (ChannelAddress_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ChannelAddress_List{l}, err
}

func (s ChannelAddress_List) At(i int) ChannelAddress { return ChannelAddress{s.List.Struct(i)} }

func (s ChannelAddress_List) Set(i int, v ChannelAddress) error { return s.List.SetStruct(i, v.Struct) }

func (s ChannelAddress_List) String() string {
	str, _ := text.MarshalList(0xd801266d9df371b7, s.List)
	return str
}

// ChannelAddress_Promise is a wrapper for a ChannelAddress promised by a client call.
type ChannelAddress_Promise struct{ *capnp.Pipeline }

func (p ChannelAddress_Promise) Struct() (ChannelAddress, error) {
	s, err := p.Pipeline.Struct()
	return ChannelAddress{s}, err
}

func (p ChannelAddress_Promise) Address() Address_Promise {
	return Address_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

const schema_87fc44aa3255d2ae = "x\xda|SA\x8b\x1cE\x14~_\xd5\xcc&\x81\xcd" +
	"n\x9a\x1ea\x09B\xbf\x83\x11#Q\xb2z0z\x89" +
	";\x89\x07\xc3\x0a[\xcc\x0e&A\x84\xda\xe92\xd30" +
	"S\xdd\xe9\xeaq]\x11\xf7\"\xb8\x04/\xd1 D\x90" +
	"\xdcs\xf0\xe0A%\x100\xe0\"\x0b\xf1\xa2\x10\xfc\x0d" +
	"\x9e\x84\\\x85\x96\x9a\xee\x99\xdd\xc3dn\xd5\xf5}\xef" +
	"\xf5\xf7}\xef\xd5\xf9=\xbc-V\x9b\xbf\x0b\"\xc5\xcd" +
	"\x85\xf2\xe1\x17?\xad\xff{\xf5\xaf{\x14,\xa1\xfc\xe1" +
	"\xcf\xeek\xf7/\xff\xf7%5\xc51\xa2\xf0]\xfc\x18" +
	"*\xf8\xd3{\xd8&\x94?\xdf|\xfa\xfd\xf0E\xfc=" +
	"\x8b{B\xfc\x13>7>\x05\xc2s\xff\xf8\xfc\xdb\x95" +
	"'\x8f\xbfzJj\x09\xe2\x08\xb9\xe1)\x8f\xc4\x83\xf0" +
	"\xc0\x93_\xdf\x17\xef\x83.\x94C\xe3\x9c\xbea^E" +
	"Og6{k-\x8e\xe2\xdc8\xb7\x01\xa8\xe3\xb2A" +
	"\xd4\x00Qp\xf6\xe5\xe0l\xa4\xd6%T_ \x00Z" +
	"\xf0\xb7\xe6t`\"\xb5'\xa1\xee\x08,g\xba\xe8\xab" +
	"\x06D\xf9\xe17\xf7\xd4\xc3'\xb7\xf6I5\x04\xd6Z" +
	"\xc0\"Q\x80\xeb\xa5\xee\x15i\xce\x99&Y\xf4\x89\xb0" +
	"D\xd8\x90\x1e\x14\xfe(\x93xN\xf1\x95\xba8\x89\x89" +
	"\xaa\x92E\xc2T\xba\xa8\xa4_\xeakk\xcd`-\x8e" +
	"\x97g8h{\x07\x1b\x12\xea\x83#\x0e\xae\xb5\x83k" +
	"\x91\xfaLB\xed\x09\xec\xf6\xaa\x063t\xac\xd4:\xee" +
	"O\xfe\xc9\xa8\xc9\xbcl\xf5\xd0\x10MD\xed\xeax\x9c" +
	"\xdf\x1c3ymF\xc7TeM\x84S\x87\xdb@\xc0" +
	"\xa9#\xe6\xea\xb9\xbcc/~l\x06if\xbc\xad\x95" +
	"\xa9\xad\xbb\xa7\x83\xbb\x91\xfaUB=\x16\x98\xb8:h" +
	"\x07\x07Q\xe7yHt^\x82@ \xd0\x82 \x0a\xcf" +
	"\xa0\x1d\x9eA\xd4Y\xf7\xc8U\x8fH\xd1\x82$\x0a\xbb" +
	"h\x87]D\x9d=\x8f\xdc\xf1HC\xb6\xd0 \x0ao" +
	"\xa3\x1d\xdeF\xd4\xf9\xc5#\xbfy\xa4y\xbc\x85&\x10" +
	">\xc2V\xb8\x8f\xa8\xb3($:+B<c\x84\x93" +
	"\xe8\xbe.G6\xb992<D\x1da\x82\xf8Hn" +
	"\xbd\xdc\xe8\xc2\xcc\xeapy\xdca\x15\xb9\x9c\xa6\xbfh" +
	"l\x95\x06\x8f\xcb\x92\xd4r\x91\x0c\x8d+\xf40\xe3W" +
	"X;\xd6\xdc\xb5\xc9'\xe3\xdbs\\\xf4\x0d\xdb\xd1p" +
	"\xcb\xe4\x9c~\xc4\xce\xf4R\x1b;6\x03\x9d9\x13\xb3" +
	"Kl\xcf\xf0\x15mG:\xdf\xe1\xd5s\xbc\xfa\xe6\x1b" +
	"\xd1y\xeen^\"B\x93\x04\x9a\x84\xdd\xdcd\x83\x9d" +
	"\xcdt\x8e\xc1\x07e\x9ay%z\x00\x1e\xb3Y_\x8c" +
	"\x0f\xe7;}\xc1\xd5|\xe7,\xdb\x0b\xb5\xdf\xeb(\xbd" +
	"pOl\xf8M\xf3\x1f\x93\x00\x12\xc7\xda\xb9\xb4\x97\xf8" +
	"\xccx;\xa9\x9e\xd4$\xcb\x9a5G\xecw\xa53y" +
	"\xa2\x07\xc9\xa70q\xd5U\xde\xf0k|\x92\x04N\x1e" +
	"\xae\xdf&\x1d\xdb\xc9f5\xbaP\x8b\xbc%\xa6C9" +
	"Q\xecdce#\x9fj\x91\xf2v\xdfX\x1e\x8e\x06" +
	"E\x92\x0d\x0c{\xd4\xf9\xfck\xbe\xe3\x9e\xb6\xbce\xd8" +
	"\x19[pjYs\x9d\x09\x01\x0b$\xb0@\xf8?\x00" +
	"\x00\xff\xff}Qh\xc3"

func init() {
	schemas.Register(schema_87fc44aa3255d2ae,
		0x9fd358f04cb684bd,
		0xd801266d9df371b7,
		0xf38cccd618967ecd)
}
