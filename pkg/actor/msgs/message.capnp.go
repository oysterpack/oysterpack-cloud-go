// Code generated by capnpc-go. DO NOT EDIT.

package msgs

import (
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Envelope struct{ capnp.Struct }

// Envelope_TypeID is the unique identifier for the type Envelope.
const Envelope_TypeID = 0xf38cccd618967ecd

func NewEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4})
	return Envelope{st}, err
}

func NewRootEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4})
	return Envelope{st}, err
}

func ReadRootEnvelope(msg *capnp.Message) (Envelope, error) {
	root, err := msg.RootPtr()
	return Envelope{root.Struct()}, err
}

func (s Envelope) String() string {
	str, _ := text.Marshal(0xf38cccd618967ecd, s.Struct)
	return str
}

func (s Envelope) Id() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Envelope) HasId() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Envelope) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Envelope) SetId(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Envelope) Created() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Envelope) SetCreated(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Envelope) ReplyTo() (ChannelAddress, error) {
	p, err := s.Struct.Ptr(1)
	return ChannelAddress{Struct: p.Struct()}, err
}

func (s Envelope) HasReplyTo() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Envelope) SetReplyTo(v ChannelAddress) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewReplyTo sets the replyTo field to a newly
// allocated ChannelAddress struct, preferring placement in s's segment.
func (s Envelope) NewReplyTo() (ChannelAddress, error) {
	ss, err := NewChannelAddress(s.Struct.Segment())
	if err != nil {
		return ChannelAddress{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope) Channel() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s Envelope) HasChannel() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Envelope) ChannelBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s Envelope) SetChannel(v string) error {
	return s.Struct.SetText(2, v)
}

func (s Envelope) Message() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Envelope) HasMessage() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Envelope) SetMessage(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Envelope) MessageType() uint8 {
	return s.Struct.Uint8(8)
}

func (s Envelope) SetMessageType(v uint8) {
	s.Struct.SetUint8(8, v)
}

// Envelope_List is a list of Envelope.
type Envelope_List struct{ capnp.List }

// NewEnvelope creates a new list of Envelope.
func NewEnvelope_List(s *capnp.Segment, sz int32) (Envelope_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4}, sz)
	return Envelope_List{l}, err
}

func (s Envelope_List) At(i int) Envelope { return Envelope{s.List.Struct(i)} }

func (s Envelope_List) Set(i int, v Envelope) error { return s.List.SetStruct(i, v.Struct) }

func (s Envelope_List) String() string {
	str, _ := text.MarshalList(0xf38cccd618967ecd, s.List)
	return str
}

// Envelope_Promise is a wrapper for a Envelope promised by a client call.
type Envelope_Promise struct{ *capnp.Pipeline }

func (p Envelope_Promise) Struct() (Envelope, error) {
	s, err := p.Pipeline.Struct()
	return Envelope{s}, err
}

func (p Envelope_Promise) ReplyTo() ChannelAddress_Promise {
	return ChannelAddress_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Address struct{ capnp.Struct }

// Address_TypeID is the unique identifier for the type Address.
const Address_TypeID = 0x9fd358f04cb684bd

func NewAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func NewRootAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func ReadRootAddress(msg *capnp.Message) (Address, error) {
	root, err := msg.RootPtr()
	return Address{root.Struct()}, err
}

func (s Address) String() string {
	str, _ := text.Marshal(0x9fd358f04cb684bd, s.Struct)
	return str
}

func (s Address) Path() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Address) HasPath() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Address) SetPath(v capnp.TextList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Address) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Address) Id() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s Address) HasId() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Address) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s Address) SetId(v string) error {
	return s.Struct.SetText(1, v)
}

// Address_List is a list of Address.
type Address_List struct{ capnp.List }

// NewAddress creates a new list of Address.
func NewAddress_List(s *capnp.Segment, sz int32) (Address_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Address_List{l}, err
}

func (s Address_List) At(i int) Address { return Address{s.List.Struct(i)} }

func (s Address_List) Set(i int, v Address) error { return s.List.SetStruct(i, v.Struct) }

func (s Address_List) String() string {
	str, _ := text.MarshalList(0x9fd358f04cb684bd, s.List)
	return str
}

// Address_Promise is a wrapper for a Address promised by a client call.
type Address_Promise struct{ *capnp.Pipeline }

func (p Address_Promise) Struct() (Address, error) {
	s, err := p.Pipeline.Struct()
	return Address{s}, err
}

type ChannelAddress struct{ capnp.Struct }

// ChannelAddress_TypeID is the unique identifier for the type ChannelAddress.
const ChannelAddress_TypeID = 0xd801266d9df371b7

func NewChannelAddress(s *capnp.Segment) (ChannelAddress, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ChannelAddress{st}, err
}

func NewRootChannelAddress(s *capnp.Segment) (ChannelAddress, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ChannelAddress{st}, err
}

func ReadRootChannelAddress(msg *capnp.Message) (ChannelAddress, error) {
	root, err := msg.RootPtr()
	return ChannelAddress{root.Struct()}, err
}

func (s ChannelAddress) String() string {
	str, _ := text.Marshal(0xd801266d9df371b7, s.Struct)
	return str
}

func (s ChannelAddress) Channel() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s ChannelAddress) HasChannel() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ChannelAddress) ChannelBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s ChannelAddress) SetChannel(v string) error {
	return s.Struct.SetText(0, v)
}

func (s ChannelAddress) Address() (Address, error) {
	p, err := s.Struct.Ptr(1)
	return Address{Struct: p.Struct()}, err
}

func (s ChannelAddress) HasAddress() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ChannelAddress) SetAddress(v Address) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s ChannelAddress) NewAddress() (Address, error) {
	ss, err := NewAddress(s.Struct.Segment())
	if err != nil {
		return Address{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// ChannelAddress_List is a list of ChannelAddress.
type ChannelAddress_List struct{ capnp.List }

// NewChannelAddress creates a new list of ChannelAddress.
func NewChannelAddress_List(s *capnp.Segment, sz int32) (ChannelAddress_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ChannelAddress_List{l}, err
}

func (s ChannelAddress_List) At(i int) ChannelAddress { return ChannelAddress{s.List.Struct(i)} }

func (s ChannelAddress_List) Set(i int, v ChannelAddress) error { return s.List.SetStruct(i, v.Struct) }

func (s ChannelAddress_List) String() string {
	str, _ := text.MarshalList(0xd801266d9df371b7, s.List)
	return str
}

// ChannelAddress_Promise is a wrapper for a ChannelAddress promised by a client call.
type ChannelAddress_Promise struct{ *capnp.Pipeline }

func (p ChannelAddress_Promise) Struct() (ChannelAddress, error) {
	s, err := p.Pipeline.Struct()
	return ChannelAddress{s}, err
}

func (p ChannelAddress_Promise) Address() Address_Promise {
	return Address_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

const schema_87fc44aa3255d2ae = "x\xda|S\xcf\x8b\x1cE\x14~_\xd5\xccf\x85\xcd" +
	"n\x9a\x1ea\x09B\xbf\x83\x11#Q\xb2*\xf8\xe3\x12" +
	"w\x12\x0f\x86\x15\xb6\x98\x1dL\x82\x08\xb5\xdde\xa6a" +
	"\xa6\xba\xd3\xd5\xe3\xba\"\xeeE\xc8\"^\xa2A\x88 " +
	"\xb9\xe7\xe0\xc1\x83J `\xc0E\x16\xe2E!\xf87" +
	"x\x12r\x15Zj\xa6gv\x0f\xe3\xdc\xaa\xeb\xfb\xde" +
	"\xeb\xef\xfb\xde\xab\xf37\xf1\x96Xk\xfe&\x88\x147" +
	"\x17\xaa\x07\x9f\xff\xb8\xf1\xcf\x95?\xefR\xb0\x8c\xea\xfb" +
	"?\xba/\xdf\xbb\xf4\xefMj\x8a\x13D\xe1;\xf8!" +
	"T\xf0\xa7w\xb1C\xa8~\xba\xf1\xe4\xbb\xc1s\xf8k" +
	"\x16\xf7)\xf1w\xf8\xf4\xe8\x14\x08\xcf\xfd\xfd\xb3oV" +
	"\x1f?\xfa\xf2\x09\xa9e\x88c\xe4\x86\xa7<\x14\xf7\xc3" +
	"CO~\xe5@\xbc\x07z\xbd\x1a\x18\xe7\xf4u\xf3\x12" +
	"b\x9d\xdb\xfc\xcd\xf5$J\x0a\xe3\xdc&\xa0\x16e\x83" +
	"\xa8\x01\xa2\xe0\xec\x0b\xc1\xd9HmH\xa8\x9e@\x00\xb4" +
	"\xe0o\xcd\xe9\xc0Dj_B\xdd\x16X\xc9u\xd9S" +
	"\x0d\x88\xea\x83\xaf\xef\xaa\x07\x8f\xbf8 \xd5\x10Xo" +
	"\x01KD\x01\xaeU:.\xb3\x82sM\xb2\xec\x11a" +
	"\x99\xb0)=(\xfcQ\xa6\xc9\x9c\xe2\xcbuq\x9a\x10" +
	"\x8dK\x96\x08S\xe9b,\xfdbO[k\xfa\xebI" +
	"\xb22\xc3A\xdb;\xd8\x94P\xef\x1fsp\xb5\x1d\\" +
	"\x8d\xd4\xa7\x12j_`/\x1e7\x98\xa1c\xb5\xd6q" +
	"o\xf2OFM\xe6\x15\xab\x07\x86h\"jO'\xa3" +
	"\xfc\xe6\x98)j3:\xa1q\xd6D8u\xb4\x0d\x04" +
	"\x9c:f\xae\x9e\xcb\xdb\xf6\xc2G\xa6\x9f\xe5\xc6\xdbZ" +
	"\x9d\xda\xbas:\xb8\x13\xa9_$\xd4#\x81\x89\xab\xc3" +
	"vp\x18u\x9e\x81D\xe7y\x08\x04\x02-\x08\xa2\xf0" +
	"\x0c\xda\xe1\x19D\x9d\x0d\x8f\\\xf1\x88\x14-H\xa2\xb0" +
	"\x8bv\xd8E\xd4\xd9\xf7\xc8m\x8f4d\x0b\x0d\xa2\xf0" +
	"\x16\xda\xe1-D\x9d\x9f=\xf2\xabG\x9a\x8b-4\x81" +
	"\xf0!\xb6\xc3\x03D\x9dE!\xd1i\x09\xf1?#\x9c" +
	"D\xf7U5\xb4\xe9\x8d\xa1\xe1\x01\xea\x08S$\xc7r" +
	"\x8b\x0b\xa3K3\xab\xc3\xa5Q\x875\x14r\x9a\xfe\x92" +
	"\xb1\xe34xT\x96f\x96\xcbt`\\\xa9\x079\xbf" +
	"\xc8\xda\xb1\xe6\xaeM?\x1e\xdd\x9e\xe3\xb2g\xd8\x0e\x07" +
	"\xdb\xa6\xe0\xecCv&\xcel\xe2\xd8\xf4u\xeeL\xc2" +
	".\xb5\xb1\xe1\xcb\xda\x0eu\xb1\xcbk\xe7x\xed\x8d\xd7" +
	"\xa2\xf3\xdc\xdd\xbaH\x84&\x094\x09{\x85\xc9\xfb\xbb" +
	"[\xd9\x1c\x83\xf7\xab,\xf7Jt\x1f<b\xb3\xbe\x90" +
	"\x1c\xcdw\xfa\x82\xc7\xf3\x9d\xb3l\xcf\xd6~\xaf\xa1\xf2" +
	"\xc2=\xb1\xe17\xcd\x7fL\x02H\x1dk\xe7\xb28\xf5" +
	"\x99\xf1N:~R\x93,k\xd6\x1c\xb1\xdfV\xce\x14" +
	"\xa9\xee\xa7\x9f\xc0$\xe3\xae\xf2\xba_\xe3\x93$p\xf2" +
	"h\xfd\xb6\xe8\xc4n>\xab\xd1\xab\x93\xa1\x88\xe9P\x16" +
	"\xcb\xdd|\xa4l\xe8S\xdd\xe9\x19\xcb\x83a\xbfL\xf3" +
	"\xbea\x0f9\x1f~Mv\x1ck\xcb\xdb\x86\x9d\xb1%" +
	"g\x965\xc7\xbdh\x94\x08\x11\x16H`\x81\xf0_\x00" +
	"\x00\x00\xff\xff\x83\xd0g\xb8"

func init() {
	schemas.Register(schema_87fc44aa3255d2ae,
		0x9fd358f04cb684bd,
		0xd801266d9df371b7,
		0xf38cccd618967ecd)
}
