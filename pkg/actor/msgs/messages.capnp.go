// Code generated by capnpc-go. DO NOT EDIT.

package msgs

import (
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Envelope struct{ capnp.Struct }

// Envelope_TypeID is the unique identifier for the type Envelope.
const Envelope_TypeID = 0xf38cccd618967ecd

func NewEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Envelope{st}, err
}

func NewRootEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Envelope{st}, err
}

func ReadRootEnvelope(msg *capnp.Message) (Envelope, error) {
	root, err := msg.RootPtr()
	return Envelope{root.Struct()}, err
}

func (s Envelope) String() string {
	str, _ := text.Marshal(0xf38cccd618967ecd, s.Struct)
	return str
}

func (s Envelope) Id() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Envelope) HasId() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Envelope) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Envelope) SetId(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Envelope) Created() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Envelope) SetCreated(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Envelope) Address() (Address, error) {
	p, err := s.Struct.Ptr(1)
	return Address{Struct: p.Struct()}, err
}

func (s Envelope) HasAddress() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Envelope) SetAddress(v Address) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s Envelope) NewAddress() (Address, error) {
	ss, err := NewAddress(s.Struct.Segment())
	if err != nil {
		return Address{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope) MessageType() uint32 {
	return s.Struct.Uint32(8)
}

func (s Envelope) SetMessageType(v uint32) {
	s.Struct.SetUint32(8, v)
}

func (s Envelope) ReplyTo() (Envelope_ReplyTo, error) {
	p, err := s.Struct.Ptr(2)
	return Envelope_ReplyTo{Struct: p.Struct()}, err
}

func (s Envelope) HasReplyTo() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Envelope) SetReplyTo(v Envelope_ReplyTo) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewReplyTo sets the replyTo field to a newly
// allocated Envelope_ReplyTo struct, preferring placement in s's segment.
func (s Envelope) NewReplyTo() (Envelope_ReplyTo, error) {
	ss, err := NewEnvelope_ReplyTo(s.Struct.Segment())
	if err != nil {
		return Envelope_ReplyTo{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope) CorrelationId() (string, error) {
	p, err := s.Struct.Ptr(3)
	return p.Text(), err
}

func (s Envelope) HasCorrelationId() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Envelope) CorrelationIdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return p.TextBytes(), err
}

func (s Envelope) SetCorrelationId(v string) error {
	return s.Struct.SetText(3, v)
}

func (s Envelope) Message() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return []byte(p.Data()), err
}

func (s Envelope) HasMessage() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Envelope) SetMessage(v []byte) error {
	return s.Struct.SetData(4, v)
}

// Envelope_List is a list of Envelope.
type Envelope_List struct{ capnp.List }

// NewEnvelope creates a new list of Envelope.
func NewEnvelope_List(s *capnp.Segment, sz int32) (Envelope_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5}, sz)
	return Envelope_List{l}, err
}

func (s Envelope_List) At(i int) Envelope { return Envelope{s.List.Struct(i)} }

func (s Envelope_List) Set(i int, v Envelope) error { return s.List.SetStruct(i, v.Struct) }

func (s Envelope_List) String() string {
	str, _ := text.MarshalList(0xf38cccd618967ecd, s.List)
	return str
}

// Envelope_Promise is a wrapper for a Envelope promised by a client call.
type Envelope_Promise struct{ *capnp.Pipeline }

func (p Envelope_Promise) Struct() (Envelope, error) {
	s, err := p.Pipeline.Struct()
	return Envelope{s}, err
}

func (p Envelope_Promise) Address() Address_Promise {
	return Address_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Envelope_Promise) ReplyTo() Envelope_ReplyTo_Promise {
	return Envelope_ReplyTo_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Envelope_ReplyTo struct{ capnp.Struct }

// Envelope_ReplyTo_TypeID is the unique identifier for the type Envelope_ReplyTo.
const Envelope_ReplyTo_TypeID = 0xab748f26e2efa4c7

func NewEnvelope_ReplyTo(s *capnp.Segment) (Envelope_ReplyTo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Envelope_ReplyTo{st}, err
}

func NewRootEnvelope_ReplyTo(s *capnp.Segment) (Envelope_ReplyTo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Envelope_ReplyTo{st}, err
}

func ReadRootEnvelope_ReplyTo(msg *capnp.Message) (Envelope_ReplyTo, error) {
	root, err := msg.RootPtr()
	return Envelope_ReplyTo{root.Struct()}, err
}

func (s Envelope_ReplyTo) String() string {
	str, _ := text.Marshal(0xab748f26e2efa4c7, s.Struct)
	return str
}

func (s Envelope_ReplyTo) Address() (Address, error) {
	p, err := s.Struct.Ptr(0)
	return Address{Struct: p.Struct()}, err
}

func (s Envelope_ReplyTo) HasAddress() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Envelope_ReplyTo) SetAddress(v Address) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s Envelope_ReplyTo) NewAddress() (Address, error) {
	ss, err := NewAddress(s.Struct.Segment())
	if err != nil {
		return Address{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope_ReplyTo) MessageType() uint32 {
	return s.Struct.Uint32(0)
}

func (s Envelope_ReplyTo) SetMessageType(v uint32) {
	s.Struct.SetUint32(0, v)
}

// Envelope_ReplyTo_List is a list of Envelope_ReplyTo.
type Envelope_ReplyTo_List struct{ capnp.List }

// NewEnvelope_ReplyTo creates a new list of Envelope_ReplyTo.
func NewEnvelope_ReplyTo_List(s *capnp.Segment, sz int32) (Envelope_ReplyTo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Envelope_ReplyTo_List{l}, err
}

func (s Envelope_ReplyTo_List) At(i int) Envelope_ReplyTo { return Envelope_ReplyTo{s.List.Struct(i)} }

func (s Envelope_ReplyTo_List) Set(i int, v Envelope_ReplyTo) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Envelope_ReplyTo_List) String() string {
	str, _ := text.MarshalList(0xab748f26e2efa4c7, s.List)
	return str
}

// Envelope_ReplyTo_Promise is a wrapper for a Envelope_ReplyTo promised by a client call.
type Envelope_ReplyTo_Promise struct{ *capnp.Pipeline }

func (p Envelope_ReplyTo_Promise) Struct() (Envelope_ReplyTo, error) {
	s, err := p.Pipeline.Struct()
	return Envelope_ReplyTo{s}, err
}

func (p Envelope_ReplyTo_Promise) Address() Address_Promise {
	return Address_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Address struct{ capnp.Struct }

// Address_TypeID is the unique identifier for the type Address.
const Address_TypeID = 0x9fd358f04cb684bd

func NewAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func NewRootAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func ReadRootAddress(msg *capnp.Message) (Address, error) {
	root, err := msg.RootPtr()
	return Address{root.Struct()}, err
}

func (s Address) String() string {
	str, _ := text.Marshal(0x9fd358f04cb684bd, s.Struct)
	return str
}

func (s Address) Path() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Address) HasPath() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Address) PathBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Address) SetPath(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Address) Id() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s Address) HasId() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Address) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s Address) SetId(v string) error {
	return s.Struct.SetText(1, v)
}

// Address_List is a list of Address.
type Address_List struct{ capnp.List }

// NewAddress creates a new list of Address.
func NewAddress_List(s *capnp.Segment, sz int32) (Address_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Address_List{l}, err
}

func (s Address_List) At(i int) Address { return Address{s.List.Struct(i)} }

func (s Address_List) Set(i int, v Address) error { return s.List.SetStruct(i, v.Struct) }

func (s Address_List) String() string {
	str, _ := text.MarshalList(0x9fd358f04cb684bd, s.List)
	return str
}

// Address_Promise is a wrapper for a Address promised by a client call.
type Address_Promise struct{ *capnp.Pipeline }

func (p Address_Promise) Struct() (Address, error) {
	s, err := p.Pipeline.Struct()
	return Address{s}, err
}

const schema_87fc44aa3255d2ae = "x\xda\xbcSK\x88\x1cU\x14\xbd\xe7V\xf7d\xd0\x09" +
	"\x93\xa2Z\x1cB\xa0\xdeB\x84\xc8\xcc0\x9d,\x8c\"" +
	"\x98i\xc7EB\x04\x9f=\x0dADxS\xf52\xfd" +
	"\xa0\xbb\xaaR\xaf\xda\x99\x11q6\x11?\x08\xc1\x0f\x82" +
	"n\xa2\xe0B\x14\\\x19\x17\xc2\x80\x08\x92\x8dn\"d" +
	"\xe5J\x08\x88\x1b\x05W\x82P\xf2\xba\xab?\x8cc\x96" +
	"\xee\x8aw\xee\xb9\xf7\x9c{O\xad}\x86\xf3\xdc\xac\xdf" +
	"b\")\xeas\xe5\xc1\xb5\xaf/\xfdq\xf9\xa7\x1b\xe4" +
	"/\xa2\xfc\xf2v\xe7\xcc\xe7\x1b\x7f\xbfNu>F\x14" +
	"\\\xc07\x81\x84\xfbz\x06;\x84\xf2\xd6\xa7\xbf\xff\xf2" +
	"\xf0\xf5\xe2\x0b\x92K@\xf9\xe3\xab\x1f,\xdd\xf9\xe1\xed" +
	"?\xa9\xeeJ\xce\xfe\x05F0\xe2\x81]\xf5\x04\x97\x8b" +
	"\xe0\x99\xd6uW\xf2\x0e\x7f\x17|\xc8\x0f\x12\x9d\xfd\x84" +
	"\xaf\x83\xce\x95}m\xad\xda\xd6\x16\xab\x91\xca\x92\xec\xf1" +
	"\xf5'\xe38\xd7\xd6>\x0b\xc8y\xafFT\x03\x91\x7f" +
	"\xfa\x11\xfft(/y\x90\x97\x19>\xd0\x80{\xed\x9c" +
	"\xf4;\xa1\xdc\xf5 \xaf1\x163Ute\x0d\\\xbe" +
	"\xf8\xde\x0dyp\xe7\xad\xefI\xd6\x18\xeb\x0d`\x81\xc8" +
	"\xc7\xf3\xa5\x8a\x8a4\x17\x99\"\xaf\xe8\x12a\x81\x18\x0b" +
	"\x04\xcf\xc4\xf7`]\xacX&&\xc2\x982\x11\xedU" +
	"\xa2\x9fN^\xd2\xbd4\xd3\xab\xcf\xe9\xac\xb7\xb7\x99\xd2" +
	"!\xf5-\"\xf9\x90\x07\xb9\xc6\x18k_\xd9\xf2\x9b\xa1" +
	"|\xc1\x83\xec2\xf6\xd5\xc84NL\xefB\xc0\x89\xe9" +
	"\xa8M:\xb6\x97\xe9#\x84\x9e\x1a\x0am\x82Q\x16]" +
	"-\xf4n\xa6\xbd\xa8\xd0\xb1\xc8\x9d\x14Q\xd1E\xb1\x97" +
	"i\"\xc2<1\xe6g\x1c\xf0!\x07$k\x989\xb8" +
	"\x8f\xd6~\xe5I\x9e\x9a\xf8\xb9y\xd2\xbf\x19\xca\x9f=" +
	"\xc8_\xa7\x86\xee\xb6\xfc\xbba\xfb\x1c<\xb47\xc0\xf0" +
	"\x19\x0d0Q\xb0\x8eV\xb0\x8e\xb0\xfd\x8aC\xdep\x88" +
	"\xc7\x0dxD\xc1k\xd8\x0a\xdeD\xd8\xfe\xca!\xdf:" +
	"\xa4\xc6\x0d\xd4\x88\x82\x03\xb4\x82\x03\x84\xedy\xf6\xd0n" +
	"0\xc3\xaf{\x0d\xd4\x89\x02\x9f\xf3\xe0\x01\x0e\xdb\xb1C" +
	"2\x87\xcc\xd5\x1a\x98#\x0a\xfa\xdc\x0a\xfa\x1c\xb6\xdfw" +
	"\xc8\xc7\xcc\xffq\xd8\xa5\xea\xb0\xef\x96\x83\xc4\\\x1dh" +
	"\xd1G\xb5\"\x83x\x9a\x8a\xfd(\xd7\xaa\xd0Gu\xd8" +
	"\xa86\x9e{\xe3-\x8a\x05]\xadO\x0ci&MD" +
	"a\xfa\xda\x16\xaa\x9f\x89\x15\xa1\xacP\xa2\x93\x98\xdd\xe1" +
	"\xeb\xb2p\x87J\x06\xfd-\x9d\x8b\xf4\x8a\xb0:J\x93" +
	"\xd8\x0a\xddS\x99\xd5\xb1\xb0&\x89\xb4\xb8\xa8\x92\x81\xca" +
	"\xf7DsY4\x1f{4\\\x13\x9d\xcd\xa7\x88P'" +
	"F\x9d&\x819B\xder%\xef6\xca\x9dn:\x9c" +
	"57\x91g\xac\xa8\x98:\x16E\xba,\xcc\xaa^\x1d" +
	"\x09\x1a\xe5|\x84\xc2\x12\xfdoY\xdc\xcf\xab\x80\xfd\xbb" +
	"\xe1\x13U\xc3\xdf\xb84Il\"U\xe8\xfb\xdc.G" +
	"\xfd\x8c\x1d\x8e\x18NP\xc5\xd0\x84\xcdtd\xae\x18\xf7" +
	"0c\xc7\x8a\x1dSt\x0f\x15\x8c\xd5,\x8e\xe4\xe0\xc4" +
	"4\xf5\x95\xdd(\xcds\xddS\x05\x85&M.\x1c\x15" +
	"\x85\xf3\x95\xbe3^9\x18mT\xdc?fiQt" +
	"\x8d\x9d\x9aN\x85J\xd2\xa2\xab\xf3\xc9\xd3\x8a\x18X-" +
	"\"e\x87w\xc9\x94\xc9M\xb2-r}u\xa0m!" +
	"T\xe2\xf6f\xb34\xb1\xdaQ\xc2\xe1\xff:\x93\xd0\xaa" +
	"\xcd=2\xfeQiunT\xcf\xbc\x8c\xb1ao\xdb" +
	"y=N\x8c\xe3\x84\x7f\x02\x00\x00\xff\xff\xee\x13\xb9A"

func init() {
	schemas.Register(schema_87fc44aa3255d2ae,
		0x9fd358f04cb684bd,
		0xab748f26e2efa4c7,
		0xf38cccd618967ecd)
}
