// Code generated by capnpc-go. DO NOT EDIT.

package msgs

import (
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Envelope struct{ capnp.Struct }

// Envelope_TypeID is the unique identifier for the type Envelope.
const Envelope_TypeID = 0xf38cccd618967ecd

func NewEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Envelope{st}, err
}

func NewRootEnvelope(s *capnp.Segment) (Envelope, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5})
	return Envelope{st}, err
}

func ReadRootEnvelope(msg *capnp.Message) (Envelope, error) {
	root, err := msg.RootPtr()
	return Envelope{root.Struct()}, err
}

func (s Envelope) String() string {
	str, _ := text.Marshal(0xf38cccd618967ecd, s.Struct)
	return str
}

func (s Envelope) Id() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Envelope) HasId() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Envelope) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Envelope) SetId(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Envelope) Created() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Envelope) SetCreated(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

func (s Envelope) Address() (Address, error) {
	p, err := s.Struct.Ptr(1)
	return Address{Struct: p.Struct()}, err
}

func (s Envelope) HasAddress() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Envelope) SetAddress(v Address) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s Envelope) NewAddress() (Address, error) {
	ss, err := NewAddress(s.Struct.Segment())
	if err != nil {
		return Address{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope) MessageType() uint32 {
	return s.Struct.Uint32(8)
}

func (s Envelope) SetMessageType(v uint32) {
	s.Struct.SetUint32(8, v)
}

func (s Envelope) ReplyTo() (Envelope_ReplyTo, error) {
	p, err := s.Struct.Ptr(2)
	return Envelope_ReplyTo{Struct: p.Struct()}, err
}

func (s Envelope) HasReplyTo() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Envelope) SetReplyTo(v Envelope_ReplyTo) error {
	return s.Struct.SetPtr(2, v.Struct.ToPtr())
}

// NewReplyTo sets the replyTo field to a newly
// allocated Envelope_ReplyTo struct, preferring placement in s's segment.
func (s Envelope) NewReplyTo() (Envelope_ReplyTo, error) {
	ss, err := NewEnvelope_ReplyTo(s.Struct.Segment())
	if err != nil {
		return Envelope_ReplyTo{}, err
	}
	err = s.Struct.SetPtr(2, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope) CorrelationId() (string, error) {
	p, err := s.Struct.Ptr(3)
	return p.Text(), err
}

func (s Envelope) HasCorrelationId() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Envelope) CorrelationIdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return p.TextBytes(), err
}

func (s Envelope) SetCorrelationId(v string) error {
	return s.Struct.SetText(3, v)
}

func (s Envelope) Message() ([]byte, error) {
	p, err := s.Struct.Ptr(4)
	return []byte(p.Data()), err
}

func (s Envelope) HasMessage() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Envelope) SetMessage(v []byte) error {
	return s.Struct.SetData(4, v)
}

// Envelope_List is a list of Envelope.
type Envelope_List struct{ capnp.List }

// NewEnvelope creates a new list of Envelope.
func NewEnvelope_List(s *capnp.Segment, sz int32) (Envelope_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 5}, sz)
	return Envelope_List{l}, err
}

func (s Envelope_List) At(i int) Envelope { return Envelope{s.List.Struct(i)} }

func (s Envelope_List) Set(i int, v Envelope) error { return s.List.SetStruct(i, v.Struct) }

func (s Envelope_List) String() string {
	str, _ := text.MarshalList(0xf38cccd618967ecd, s.List)
	return str
}

// Envelope_Promise is a wrapper for a Envelope promised by a client call.
type Envelope_Promise struct{ *capnp.Pipeline }

func (p Envelope_Promise) Struct() (Envelope, error) {
	s, err := p.Pipeline.Struct()
	return Envelope{s}, err
}

func (p Envelope_Promise) Address() Address_Promise {
	return Address_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Envelope_Promise) ReplyTo() Envelope_ReplyTo_Promise {
	return Envelope_ReplyTo_Promise{Pipeline: p.Pipeline.GetPipeline(2)}
}

type Envelope_ReplyTo struct{ capnp.Struct }

// Envelope_ReplyTo_TypeID is the unique identifier for the type Envelope_ReplyTo.
const Envelope_ReplyTo_TypeID = 0xab748f26e2efa4c7

func NewEnvelope_ReplyTo(s *capnp.Segment) (Envelope_ReplyTo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Envelope_ReplyTo{st}, err
}

func NewRootEnvelope_ReplyTo(s *capnp.Segment) (Envelope_ReplyTo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Envelope_ReplyTo{st}, err
}

func ReadRootEnvelope_ReplyTo(msg *capnp.Message) (Envelope_ReplyTo, error) {
	root, err := msg.RootPtr()
	return Envelope_ReplyTo{root.Struct()}, err
}

func (s Envelope_ReplyTo) String() string {
	str, _ := text.Marshal(0xab748f26e2efa4c7, s.Struct)
	return str
}

func (s Envelope_ReplyTo) Address() (Address, error) {
	p, err := s.Struct.Ptr(0)
	return Address{Struct: p.Struct()}, err
}

func (s Envelope_ReplyTo) HasAddress() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Envelope_ReplyTo) SetAddress(v Address) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s Envelope_ReplyTo) NewAddress() (Address, error) {
	ss, err := NewAddress(s.Struct.Segment())
	if err != nil {
		return Address{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Envelope_ReplyTo) MessageType() uint32 {
	return s.Struct.Uint32(0)
}

func (s Envelope_ReplyTo) SetMessageType(v uint32) {
	s.Struct.SetUint32(0, v)
}

// Envelope_ReplyTo_List is a list of Envelope_ReplyTo.
type Envelope_ReplyTo_List struct{ capnp.List }

// NewEnvelope_ReplyTo creates a new list of Envelope_ReplyTo.
func NewEnvelope_ReplyTo_List(s *capnp.Segment, sz int32) (Envelope_ReplyTo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Envelope_ReplyTo_List{l}, err
}

func (s Envelope_ReplyTo_List) At(i int) Envelope_ReplyTo { return Envelope_ReplyTo{s.List.Struct(i)} }

func (s Envelope_ReplyTo_List) Set(i int, v Envelope_ReplyTo) error {
	return s.List.SetStruct(i, v.Struct)
}

func (s Envelope_ReplyTo_List) String() string {
	str, _ := text.MarshalList(0xab748f26e2efa4c7, s.List)
	return str
}

// Envelope_ReplyTo_Promise is a wrapper for a Envelope_ReplyTo promised by a client call.
type Envelope_ReplyTo_Promise struct{ *capnp.Pipeline }

func (p Envelope_ReplyTo_Promise) Struct() (Envelope_ReplyTo, error) {
	s, err := p.Pipeline.Struct()
	return Envelope_ReplyTo{s}, err
}

func (p Envelope_ReplyTo_Promise) Address() Address_Promise {
	return Address_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Address struct{ capnp.Struct }

// Address_TypeID is the unique identifier for the type Address.
const Address_TypeID = 0x9fd358f04cb684bd

func NewAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func NewRootAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Address{st}, err
}

func ReadRootAddress(msg *capnp.Message) (Address, error) {
	root, err := msg.RootPtr()
	return Address{root.Struct()}, err
}

func (s Address) String() string {
	str, _ := text.Marshal(0x9fd358f04cb684bd, s.Struct)
	return str
}

func (s Address) Path() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Address) HasPath() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Address) SetPath(v capnp.TextList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Address) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Address) Id() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s Address) HasId() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Address) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s Address) SetId(v string) error {
	return s.Struct.SetText(1, v)
}

// Address_List is a list of Address.
type Address_List struct{ capnp.List }

// NewAddress creates a new list of Address.
func NewAddress_List(s *capnp.Segment, sz int32) (Address_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Address_List{l}, err
}

func (s Address_List) At(i int) Address { return Address{s.List.Struct(i)} }

func (s Address_List) Set(i int, v Address) error { return s.List.SetStruct(i, v.Struct) }

func (s Address_List) String() string {
	str, _ := text.MarshalList(0x9fd358f04cb684bd, s.List)
	return str
}

// Address_Promise is a wrapper for a Address promised by a client call.
type Address_Promise struct{ *capnp.Pipeline }

func (p Address_Promise) Struct() (Address, error) {
	s, err := p.Pipeline.Struct()
	return Address{s}, err
}

const schema_87fc44aa3255d2ae = "x\xda\xbcSMh\x1dU\x14>\xe7\xcc{i\xd4\xd4" +
	"d\x98W\x0c\xa50w!B%\x09y\xed\xc2*\x82" +
	"\xcd3.Z*\xf4\xfa\x12\x10\x11\xe1f\xe64\xef\xc2" +
	"{3\xd3\xb9\xf7\x99F\xc4l\x14\xab\x08\x05-.\xdc" +
	"T\xc1\x8d?\x08\x82u!\x04D\x90ntS\xa1+" +
	"WBA\xdc(\xb8\x15F\xee\xcc\xbc\x1fb\xec\xb2\xbb" +
	"\xe1~\xf7;\xf7\xfb\xce\xf7\xcd\xea\x97x\x96\xda\xcd[" +
	"\x04 Es\xa6\xd8\x7f\xf3\xdb\x0b\x7f\xbd\xf8\xcb\x0d\xf0" +
	"\xe7\xb1\xf8\xea\xf6\xe6\xa9\xcf\xd7\xffy\x1b\x9at\x04 " +
	"8\x87\xdf\x05\x12\xdd\xd7\xf3\xb8\x03X\xdc\xfa\xf4\xcf\xdf" +
	"\x1e\xbbf\xbf\x00\xb9\x88X\xfc\xfc\xc6\x87\x8bw~z" +
	"\xefoh\xba+\xa7\x1f \xc2\xe0X\xc9\xf3\xc9\xdd\x1e" +
	"\xe3r\x1eijt\xd3]\xf9\x84~\x08>\xa3G\x00" +
	"N\x7fM\xd7\x10\xce\x14\x036Fm\xb3\xc1\x95He" +
	"I\xf6\xd4\xda3q\x9c\xb31\x17\x11\xe5\xac\xd7\x00h" +
	" \x80\x7f\xf2q\xffd(/x({\x84>b\x0b" +
	"\xdd)\x1f\xf79\x94W=\x94\xd7\x09\xe73e{\xb2" +
	"\x81T\xbc\xf2\xc1\x0d\xb9\x7f\xe7\xdd\x1fA6\x08\xd7Z" +
	"\x88s\x00>\xbeT\xa8\xc8\xa6\xb9\xc8\x14x\xb6\x07\x80" +
	"\x0f\x03^\xf4\x1cH\xee\xd3\xd3\xf1=\xc8\xe7k\xb2\x8e" +
	"\x01*\xca\x1c\xe0X\xbbWk\x7f.y\x95\xfbi\xc6" +
	"+/p\xd6\xdf\xddH\xe1\x80\x89\x0e\x80|\xd4C\xb9" +
	"J8\xb2\xb0\xbc\xe5\xb7C\xf9relOU\xdeq" +
	"a\x12\x0f .L\x9e\xda\x80#\xbb\x19\x1f\"\xf4D" +
	")\xb4\x8d\x84\x85\xed\xb1\xe0+\x19{\x91\xe5X\xe4N" +
	"\x8a\xa8\xe9\xc2\xeef\x0c\x008\x0b\x84\xb3S\x0e\xe8\x80" +
	"\x03\x90\x0d\x9c\xca\xdd\xc7\xce^\xedI\x9e\x18\xfb\xb9y" +
	"\xdc\xbf\x19\xca_=\x94\xbfO\x0c\xdd\xed\xf8w\xc3\xee" +
	"\x19\xf4\xb0\xbb\x8e\x84>a\x0b\x09 X\xc3N\xb0\x86" +
	"a\xf7u\x87\\u\x88G-\xf4\x00\x82\xb7p+x" +
	"\x07\xc3\xee7\x0e\xf9\xde!\x0dja\x03 \xd8\xc7N" +
	"\xb0\x8faw\x96<\xec\xb6\x88\xd0oz-l\x96M" +
	"\xcb\x83c\x14vc\x87d\x0e\x99i\xb4p\x06 \x18" +
	"P'\x18P\xd8\xbd\xee\x90\x8f\x89\xfe'\xd8\xc5:\xd8" +
	"\xf7\x8ba\xa2/\x0fY\x0c\xb0^\x91F\x97q\x1d\xf1" +
	"^\x94\xb3\xb2|\xd8\x84\xf5z\xe3\xb97\xda\xa2\x98\xe3" +
	"z}\xa2\xa4\xe94\x11V\x0f\xd8X5\xc8\xc4\xb2P" +
	"F(\xb1\x99\xe8+\xe5\xe9\x92pA%\xc3\xc1\x16\xe7" +
	"\"\xbd$\x0cGi\x12\x1b\xc1}\x95\x19\x8e\x85\xd1I" +
	"\xc4\xe2\xbcJ\x86*\xdf\x15\xed%\xd1~\xf2\x89pU" +
	"ln<\x0b\x80M l\xc2\xb80\x87\xc8[\xaa\xe5" +
	"\xdd\xc6b\xa7\x97\x96o\xcd\x8c\xe5i#j&\xc7\xc2" +
	"\xa6KB\xaf\xf0J%\xa8\xeay\x85\xa2\x01\xb8o]" +
	"\xdc\xcb\xeb\x82\xfdw\xe0\xd3\xf5\xc0?\xa8\xd0I\xac#" +
	"e\xf9A\xb7\xcbj\x9e6\xe5\x13\xe5\x0b\xca\x96&L" +
	"\xc6\x91\xbe\xa4\xdd\xc1\x94\x1d#v\xb4\xed\x1d\xb80R" +
	"3_\xc9\xc1\x85I\xebk\xbbQ\x9a\xe7\xdcW\x16B" +
	"\x9d&\xe7\x0e\xab\xc2\xd9Z\xdf)\xaf\x18V\x1b\x15\x0f" +
	"\x8dX,lO\x9b\x89\xe9T\xa8$\xb5=\xce\xc7G" +
	"\xcbbhXD\xca\x94\xb9dJ\xe7:\xd9\x169_" +
	"\x1e\xb2\xb1B%no&K\x13\xc3\x8e\x12\x96\xff\xeb" +
	"TC\xeb1\xf7\xe8\xf8G\x85\xe1\\\xab\xbe~\x0dG" +
	"\x86\xbdm\xe7\xf5(\x10\x1e\x05\xfc7\x00\x00\xff\xff$" +
	"L\xb9\\"

func init() {
	schemas.Register(schema_87fc44aa3255d2ae,
		0x9fd358f04cb684bd,
		0xab748f26e2efa4c7,
		0xf38cccd618967ecd)
}
